{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["import { AwesomeCordovaNativePlugin } from '@awesome-cordova-plugins/core';\nexport interface HTTPResponse {\n    /**\n     * The HTTP status number of the response or a negative internal error code.\n     */\n    status: number;\n    /**\n     * The headers of the response.\n     */\n    headers: {\n        [key: string]: string;\n    };\n    /**\n     * The URL of the response. This property will be the final URL obtained after any redirects.\n     */\n    url: string;\n    /**\n     * The data that is in the response. This property usually exists when a promise returned by a request method resolves.\n     */\n    data?: any;\n    /**\n     * Error response from the server. This property usually exists when a promise returned by a request method rejects.\n     */\n    error?: string;\n}\ninterface AbortedResponse {\n    aborted: boolean;\n}\n/**\n * @name HTTP\n * @description\n * Cordova / Phonegap plugin for communicating with HTTP servers. Supports iOS and Android.\n *\n * Advantages over Javascript requests:\n * - SSL / TLS Pinning\n * - CORS restrictions do not apply\n * - Handling of HTTP code 401 - read more at [Issue CB-2415](https://issues.apache.org/jira/browse/CB-2415)\n * @usage\n * ```typescript\n * import { HTTP } from '@awesome-cordova-plugins/http/ngx';\n *\n * constructor(private http: HTTP) {}\n *\n * ...\n *\n * this.http.get('http://ionic.io', {}, {})\n *   .then(data => {\n *\n *     console.log(data.status);\n *     console.log(data.data); // data received by server\n *     console.log(data.headers);\n *\n *   })\n *   .catch(error => {\n *\n *     console.log(error.status);\n *     console.log(error.error); // error message as string\n *     console.log(error.headers);\n *\n *   });\n *\n * ```\n * @interfaces\n * HTTPResponse\n */\nexport declare class HTTP extends AwesomeCordovaNativePlugin {\n    /**\n     * This enum represents the internal error codes which can be returned in a HTTPResponse object.\n     *\n     * @readonly\n     */\n    readonly ErrorCode: {\n        GENERIC: number;\n        SSL_EXCEPTION: number;\n        SERVER_NOT_FOUND: number;\n        TIMEOUT: number;\n        UNSUPPORTED_URL: number;\n        NOT_CONNECTED: number;\n        POST_PROCESSING_FAILED: number;\n        ABORTED: number;\n    };\n    /**\n     * This returns an object representing a basic HTTP Authorization header of the form.\n     *\n     * @param username {string} Username\n     * @param password {string} Password\n     * @returns {Object} an object representing a basic HTTP Authorization header of the form {'Authorization': 'Basic base64EncodedUsernameAndPassword'}\n     */\n    getBasicAuthHeader(username: string, password: string): {\n        Authorization: string;\n    };\n    /**\n     * This sets up all future requests to use Basic HTTP authentication with the given username and password.\n     *\n     * @param username {string} Username\n     * @param password {string} Password\n     */\n    useBasicAuth(username: string, password: string): void;\n    /**\n     * Get all headers defined for a given hostname.\n     *\n     * @param host {string} The hostname\n     * @returns {string} return all headers defined for the hostname\n     */\n    getHeaders(host: string): string;\n    /**\n     * Set a header for all future requests. Takes a hostname, a header and a value.\n     *\n     * @param host {string} The hostname to be used for scoping this header\n     * @param header {string} The name of the header\n     * @param value {string} The value of the header\n     */\n    setHeader(host: string, header: string, value: string): void;\n    /**\n     * Get the name of the data serializer which will be used for all future POST and PUT requests.\n     *\n     * @returns {string} returns the name of the configured data serializer\n     */\n    getDataSerializer(): string;\n    /**\n     * Set the data serializer which will be used for all future POST, PUT and PATCH requests. Takes a string representing the name of the serializer.\n     *\n     * @param serializer {string} The name of the serializer.\n     * @see https://github.com/silkimen/cordova-plugin-advanced-http#setdataserializer\n     */\n    setDataSerializer(serializer: 'urlencoded' | 'json' | 'utf8' | 'multipart' | 'raw'): void;\n    /**\n     * Add a custom cookie.\n     *\n     * @param url {string} Scope of the cookie\n     * @param cookie {string} RFC compliant cookie string\n     */\n    setCookie(url: string, cookie: string): void;\n    /**\n     * Clear all cookies.\n     */\n    clearCookies(): void;\n    /**\n     * Remove cookies for given URL.\n     *\n     * @param url {string}\n     * @param cb\n     */\n    removeCookies(url: string, cb: () => void): void;\n    /**\n     * Resolve cookie string for given URL.\n     *\n     * @param url {string}\n     */\n    getCookieString(url: string): string;\n    /**\n     * Get global request timeout value in seconds.\n     *\n     * @returns {number} returns the global request timeout value\n     */\n    getRequestTimeout(): number;\n    /**\n     * Set global request timeout value in seconds.\n     *\n     * @param timeout {number} The timeout in seconds. Default 60\n     */\n    setRequestTimeout(timeout: number): void;\n    /**\n     * Resolve if it should follow redirects automatically.\n     *\n     * @returns {boolean} returns true if it is configured to follow redirects automatically\n     */\n    getFollowRedirect(): boolean;\n    /**\n     * Configure if it should follow redirects automatically.\n     *\n     * @param follow {boolean} Set to false to disable following redirects automatically\n     */\n    setFollowRedirect(follow: boolean): void;\n    /**\n     * Set server trust mode, being one of the following values:\n     * default: default SSL trustship and hostname verification handling using system's CA certs;\n     * legacy: use legacy default behavior (< 2.0.3), excluding user installed CA certs (only for Android);\n     * nocheck: disable SSL certificate checking and hostname verification, trusting all certs (meant to be used only for testing purposes);\n     * pinned: trust only provided certificates;\n     *\n     * @see https://github.com/silkimen/cordova-plugin-advanced-http#setservertrustmode\n     * @param {string} mode server trust mode\n     */\n    setServerTrustMode(mode: 'default' | 'legacy' | 'nocheck' | 'pinned'): Promise<void>;\n    /**\n     * Make a POST request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    post(url: string, body: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync POST request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    postSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make a GET request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    get(url: string, parameters: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync GET request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    getSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make a PUT request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    put(url: string, body: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync PUT request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    putSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make a PATCH request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    patch(url: string, body: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync PATCH request\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    patchSync(url: string, body: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make a DELETE request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    delete(url: string, parameters: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync DELETE request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    deleteSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make a HEAD request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    head(url: string, parameters: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make a sync HEAD request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    headSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * Make an OPTIONS request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    options(url: string, parameters: any, headers: any): Promise<HTTPResponse>;\n    /**\n     * Make an sync OPTIONS request\n     *\n     * @param url {string} The url to send the request to\n     * @param parameters {Object} Parameters to send with the request\n     * @param headers {Object} The headers to set for this request\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    optionsSync(url: string, parameters: any, headers: any, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param filePath {string} The local path(s) of the file(s) to upload\n     * @param name {string} The name(s) of the parameter to pass the file(s) along as\n     * @returns {Promise<any>} returns a FileEntry promise that will resolve on success, and reject on failure\n     */\n    uploadFile(url: string, body: any, headers: any, filePath: string | string[], name: string | string[]): Promise<any>;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param filePath {string} The local path(s) of the file(s) to upload\n     * @param name {string} The name(s) of the parameter to pass the file(s) along as\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    uploadFileSync(url: string, body: any, headers: any, filePath: string | string[], name: string | string[], success: (result: any) => void, failure: (error: any) => void): string;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param filePath {string} The path to download the file to, including the file name.\n     * @returns {Promise<any>} returns a FileEntry promise that will resolve on success, and reject on failure\n     */\n    downloadFile(url: string, body: any, headers: any, filePath: string): Promise<any>;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param body {Object} The body of the request\n     * @param headers {Object} The headers to set for this request\n     * @param filePath {string} The path to download the file to, including the file name.\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    downloadFileSync(url: string, body: any, headers: any, filePath: string, success: (result: any) => void, failure: (error: any) => void): string;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param options {Object} options for individual request\n     * @param options.method {string} request method\n     * @param options.data {Object} payload to be send to the server (only applicable on post, put or patch methods)\n     * @param options.params {Object} query params to be appended to the URL (only applicable on get, head, delete, upload or download methods)\n     * @param options.serializer {string} data serializer to be used (only applicable on post, put or patch methods), defaults to global serializer value, see setDataSerializer for supported values\n     * @param options.timeout {number} timeout value for the request in seconds, defaults to global timeout value\n     * @param options.headers {Object} headers object (key value pair), will be merged with global values\n     * @param options.filePath {string} file path(s) to be used during upload and download see uploadFile and downloadFile for detailed information\n     * @param options.name {string} name(s) to be used during upload see uploadFile for detailed information\n     * @param options.responseType {string} response type, defaults to text\n     * @returns {Promise<HTTPResponse>} returns a promise that will resolve on success, and reject on failure\n     */\n    sendRequest(url: string, options: {\n        method: 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'upload' | 'download';\n        data?: {\n            [index: string]: any;\n        };\n        params?: {\n            [index: string]: string | number;\n        };\n        serializer?: 'json' | 'urlencoded' | 'utf8' | 'multipart' | 'raw';\n        timeout?: number;\n        headers?: {\n            [index: string]: string;\n        };\n        filePath?: string | string[];\n        name?: string | string[];\n        responseType?: 'text' | 'arraybuffer' | 'blob' | 'json';\n    }): Promise<HTTPResponse>;\n    /**\n     *\n     * @param url {string} The url to send the request to\n     * @param options {Object} options for individual request\n     * @param options.method {string} request method\n     * @param options.data {Object} payload to be send to the server (only applicable on post, put or patch methods)\n     * @param options.params {Object} query params to be appended to the URL (only applicable on get, head, delete, upload or download methods)\n     * @param options.serializer {string} data serializer to be used (only applicable on post, put or patch methods), defaults to global serializer value, see setDataSerializer for supported values\n     * @param options.timeout {number} timeout value for the request in seconds, defaults to global timeout value\n     * @param options.headers {Object} headers object (key value pair), will be merged with global values\n     * @param options.filePath {string} file path(s) to be used during upload and download see uploadFile and downloadFile for detailed information\n     * @param options.name {string} name(s) to be used during upload see uploadFile for detailed information\n     * @param options.responseType {string} response type, defaults to text\n     * @param success {function} A callback that is called when the request succeed\n     * @param failure {function} A callback that is called when the request failed\n     * @returns {string} returns a string that represents the requestId\n     */\n    sendRequestSync(url: string, options: {\n        method: 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'upload' | 'download';\n        data?: {\n            [index: string]: any;\n        };\n        params?: {\n            [index: string]: string | number;\n        };\n        serializer?: 'json' | 'urlencoded' | 'utf8' | 'multipart';\n        timeout?: number;\n        headers?: {\n            [index: string]: string;\n        };\n        filePath?: string | string[];\n        name?: string | string[];\n        responseType?: 'text' | 'arraybuffer' | 'blob' | 'json';\n    }, success: (result: HTTPResponse) => void, failure: (error: any) => void): string;\n    /**\n     * @param requestId {string} The RequestId of the request to abort\n     */\n    abort(requestId: string): Promise<AbortedResponse>;\n}\nexport {};\n"]}